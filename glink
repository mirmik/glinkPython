#!/usr/bin/env python3
#coding: utf8

import sys
sys.path.append("./mk")

#from glink.lang.lex import lexfile as lexfile
from glink.lang.pars import parse_file

file = open('./exampletext')
#toks = lexfile(file)

# for tok in toks:
#     if tok.type in ["WORD","STRING","NUMBER","FLOAT", "SUPERWORD"]:
#     	print(tok.type, tok.value)
#     else:
#     	print(tok.type)


modules = []
class context:
	def __init__(self):
		self.variables = []

	def __repr__(self):
		return str(self.variables)
	
contextlevels = []


def add_var(name, var):
	sss = None
	for v in contextlevels[-1].variables:
		if v[0] == name:
		 	sss = v
		 	break
	if sss == None:
		contextlevels[-1].variables.append([name, var]);
	else:
		sss[1] = var
	#print(name)

def get_var(name):
	for context in contextlevels[::-1]:
		for v in context.variables:
			if v[0] == name:
				return v[1]
	print("wrong variable")
	exit()

seed = 0

def see(f):
	def func(*e):
		if seed == 1:
			print(f.__name__)
			print (*e)
		ret = f(*e)
		return ret
	return func






@see
def moduleblock(name, blk):



	modules.append([name,[]]); 
	pass



@see
def execblock(blk):
	c = context()
	contextlevels.append(c)
	ret = None
	for p in blk.parts:
		ret = evaluate(p)
	del contextlevels[-1]
	return ret
		


@see
def evaluate(expr):	
	if expr.type == 'int': return expr.parts[0] 
	if expr.type == '+': return evaluate(expr.parts[0]) + evaluate(expr.parts[1]) 
	if expr.type == '*': return evaluate(expr.parts[0]) * evaluate(expr.parts[1]) 
	if expr.type == '-': return evaluate(expr.parts[0]) - evaluate(expr.parts[1]) 
	if expr.type == '/': return evaluate(expr.parts[0]) / evaluate(expr.parts[1]) 
	if expr.type == '**': return evaluate(expr.parts[0]) ** evaluate(expr.parts[1]) 
	if expr.type == 'deffunc': add_var(expr.parts[0].parts[0], [expr.parts[0],expr.parts[1]]); return 0
	if expr.type == 'var': return get_var(expr.parts[0]) 
	if expr.type == 'module': moduleblock(expr.parts[0], expr.parts[1]); return 0 
	if expr.type == 'inblock': return execblock(expr) 
	if expr.type == 'print': 
		ev = evaluate(expr.parts[0])
		print(ev)
		return(ev)


	if expr.type == 'func': 
		contextlevels.append(context())
		v = get_var(expr.parts[0])
		for z in zip(v[0].parts[1].parts, expr.parts[1].parts):
			add_var(z[0].parts[0], z[1].parts[0])
		ret = evaluate(v[1])
		del contextlevels[-1]
		return(ret)


	if expr.type == 'define':
		ev = evaluate(expr.parts[1])
		add_var(expr.parts[0], evaluate(expr.parts[1]))
		return(ev)
	print(expr, "EVALUATE ERROR")
	exit()

seed = 0
metablock = parse_file(file)
#print(metablock)
execblock(metablock)
print("modules: ", modules)



file.close()
